# Lock 

## 锁

#### 1.线程安全

当一个线程访问数据的时候，其他的线程不能对其进行访问，直到该线程访问完毕。简单来讲就是在同一时刻，对同一个数据操作的线程只有一个。而线程不安全，则是在同一时刻可以有多个线程对该数据进行访问，从而得不到预期的结果

**即线程内操作了一个线程外的非线程安全变量，这个时候一定要考虑线程安全和同步**

#### 2.检测安全



![img](http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2021-03-03-065714.jpg)



#### 3.锁的作用

`锁`作为一种非强制的机制，被用来保证线程安全。每一个线程在访问数据或者资源前，要先获取（`Acquire`）锁，并在访问结束之后释放（`Release`）锁。如果锁已经被占用，其它试图获取锁的线程会等待，直到锁重新可用

**注：不要将过多的其他操作代码放到锁里面，否则一个线程执行的时候另一个线程就一直在等待，就无法发挥多线程的作用了**

#### 4.锁的分类

在iOS中锁的基本种类只有两种：`互斥锁`、`自旋锁`，其他的比如`条件锁`、`递归锁`、`信号量`都是上层的封装和实现

而在JAVA中锁占有更大份额，有兴趣可以去研究一下

#### 5. 互斥锁

`互斥锁`(Mutual exclusion，缩写`Mutex`)防止两条线程同时对同一公共资源(比如全局变量)进行读写的机制。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒

`互斥锁`又分为：

- `递归锁`：可重入锁，同一个线程在锁释放前可再次获取锁，即可以递归调用
- `非递归锁`：不可重入，必须等锁释放后才能再次获取锁

#### 6. 自旋锁

`自旋锁`：线程反复检查锁变量是否可⽤。由于线程在这⼀过程中保持执⾏， 因此是⼀种`忙等待`。⼀旦获取了⾃旋锁，线程会⼀直保持该锁，直⾄显式释 放⾃旋锁

`⾃旋锁`避免了进程上下⽂的调度开销，因此对于线程只会阻塞很短时间的场合是有效的

#### 7.互斥锁和自旋锁的区别

- `互斥锁`在线程获取锁但没有获取到时，线程会进入休眠状态，等锁被释放时线程会被唤醒
- `自旋锁`的线程则会一直处于等待状态（忙等待）不会进入休眠——因此效率高

